{"version":3,"file":"wrappers__auth.aff15127.async.js","mappings":"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","sources":["webpack:///./src/hooks/auth-hooks.ts","webpack:///./src/wrappers/auth.tsx","webpack:///./node_modules/antd/es/message/index.js"],"sourcesContent":["import authorizationUtil from '@/utils/authorization-util';\nimport { message } from 'antd';\nimport { useEffect, useMemo, useState } from 'react';\nimport { useNavigate, useSearchParams } from 'umi';\n\nexport const useLoginWithGithub = () => {\n  const [currentQueryParameters, setSearchParams] = useSearchParams();\n  const error = currentQueryParameters.get('error');\n  const newQueryParameters: URLSearchParams = useMemo(\n    () => new URLSearchParams(currentQueryParameters.toString()),\n    [currentQueryParameters],\n  );\n  const navigate = useNavigate();\n\n  if (error) {\n    message.error(error);\n    navigate('/login');\n    newQueryParameters.delete('error');\n    setSearchParams(newQueryParameters);\n    return;\n  }\n\n  const auth = currentQueryParameters.get('auth');\n\n  if (auth) {\n    authorizationUtil.setAuthorization(auth);\n    newQueryParameters.delete('auth');\n    setSearchParams(newQueryParameters);\n  }\n  return auth;\n};\n\nexport const useAuth = () => {\n  const auth = useLoginWithGithub();\n  const [isLogin, setIsLogin] = useState<Nullable<boolean>>(null);\n\n  useEffect(() => {\n    setIsLogin(!!authorizationUtil.getAuthorization() || !!auth);\n  }, [auth]);\n\n  return { isLogin };\n};\n","import { useAuth } from '@/hooks/auth-hooks';\nimport { redirectToLogin } from '@/utils/authorization-util';\nimport { Outlet } from 'umi';\n\nexport default () => {\n  const { isLogin } = useAuth();\n  if (isLogin === true) {\n    return <Outlet />;\n  } else if (isLogin === false) {\n    redirectToLogin();\n  }\n\n  return <></>;\n};\n","\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { render } from \"rc-util/es/React/render\";\nimport ConfigProvider, { globalConfig, warnContext } from '../config-provider';\nimport PurePanel from './PurePanel';\nimport useMessage, { useInternalMessage } from './useMessage';\nimport { wrapPromiseFn } from './util';\nlet message = null;\nlet act = callback => callback();\nlet taskQueue = [];\nlet defaultGlobalConfig = {};\nfunction getGlobalContext() {\n  const {\n    prefixCls: globalPrefixCls,\n    getContainer: globalGetContainer,\n    duration,\n    rtl,\n    maxCount,\n    top\n  } = defaultGlobalConfig;\n  const mergedPrefixCls = globalPrefixCls !== null && globalPrefixCls !== void 0 ? globalPrefixCls : globalConfig().getPrefixCls('message');\n  const mergedContainer = (globalGetContainer === null || globalGetContainer === void 0 ? void 0 : globalGetContainer()) || document.body;\n  return {\n    prefixCls: mergedPrefixCls,\n    getContainer: () => mergedContainer,\n    duration,\n    rtl,\n    maxCount,\n    top\n  };\n}\nconst GlobalHolder = /*#__PURE__*/React.forwardRef((_, ref) => {\n  const [messageConfig, setMessageConfig] = React.useState(getGlobalContext);\n  const [api, holder] = useInternalMessage(messageConfig);\n  const global = globalConfig();\n  const rootPrefixCls = global.getRootPrefixCls();\n  const rootIconPrefixCls = global.getIconPrefixCls();\n  const theme = global.getTheme();\n  const sync = () => {\n    setMessageConfig(getGlobalContext);\n  };\n  React.useEffect(sync, []);\n  React.useImperativeHandle(ref, () => {\n    const instance = Object.assign({}, api);\n    Object.keys(instance).forEach(method => {\n      instance[method] = function () {\n        sync();\n        return api[method].apply(api, arguments);\n      };\n    });\n    return {\n      instance,\n      sync\n    };\n  });\n  return /*#__PURE__*/React.createElement(ConfigProvider, {\n    prefixCls: rootPrefixCls,\n    iconPrefixCls: rootIconPrefixCls,\n    theme: theme\n  }, holder);\n});\nfunction flushNotice() {\n  if (!message) {\n    const holderFragment = document.createDocumentFragment();\n    const newMessage = {\n      fragment: holderFragment\n    };\n    message = newMessage;\n    // Delay render to avoid sync issue\n    act(() => {\n      render( /*#__PURE__*/React.createElement(GlobalHolder, {\n        ref: node => {\n          const {\n            instance,\n            sync\n          } = node || {};\n          // React 18 test env will throw if call immediately in ref\n          Promise.resolve().then(() => {\n            if (!newMessage.instance && instance) {\n              newMessage.instance = instance;\n              newMessage.sync = sync;\n              flushNotice();\n            }\n          });\n        }\n      }), holderFragment);\n    });\n    return;\n  }\n  // Notification not ready\n  if (!message.instance) {\n    return;\n  }\n  // >>> Execute task\n  taskQueue.forEach(task => {\n    const {\n      type,\n      skipped\n    } = task;\n    // Only `skipped` when user call notice but cancel it immediately\n    // and instance not ready\n    if (!skipped) {\n      switch (type) {\n        case 'open':\n          {\n            act(() => {\n              const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));\n              closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);\n              task.setCloseFn(closeFn);\n            });\n            break;\n          }\n        case 'destroy':\n          act(() => {\n            message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);\n          });\n          break;\n        // Other type open\n        default:\n          {\n            act(() => {\n              var _message$instance;\n              const closeFn = (_message$instance = message.instance)[type].apply(_message$instance, _toConsumableArray(task.args));\n              closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);\n              task.setCloseFn(closeFn);\n            });\n          }\n      }\n    }\n  });\n  // Clean up\n  taskQueue = [];\n}\n// ==============================================================================\n// ==                                  Export                                  ==\n// ==============================================================================\nfunction setMessageGlobalConfig(config) {\n  defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);\n  // Trigger sync for it\n  act(() => {\n    var _a;\n    (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);\n  });\n}\nfunction open(config) {\n  const result = wrapPromiseFn(resolve => {\n    let closeFn;\n    const task = {\n      type: 'open',\n      config,\n      resolve,\n      setCloseFn: fn => {\n        closeFn = fn;\n      }\n    };\n    taskQueue.push(task);\n    return () => {\n      if (closeFn) {\n        act(() => {\n          closeFn();\n        });\n      } else {\n        task.skipped = true;\n      }\n    };\n  });\n  flushNotice();\n  return result;\n}\nfunction typeOpen(type, args) {\n  // Warning if exist theme\n  if (process.env.NODE_ENV !== 'production') {\n    warnContext('message');\n  }\n  const result = wrapPromiseFn(resolve => {\n    let closeFn;\n    const task = {\n      type,\n      args,\n      resolve,\n      setCloseFn: fn => {\n        closeFn = fn;\n      }\n    };\n    taskQueue.push(task);\n    return () => {\n      if (closeFn) {\n        act(() => {\n          closeFn();\n        });\n      } else {\n        task.skipped = true;\n      }\n    };\n  });\n  flushNotice();\n  return result;\n}\nfunction destroy(key) {\n  taskQueue.push({\n    type: 'destroy',\n    key\n  });\n  flushNotice();\n}\nconst methods = ['success', 'info', 'warning', 'error', 'loading'];\nconst baseStaticMethods = {\n  open,\n  destroy,\n  config: setMessageGlobalConfig,\n  useMessage,\n  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel\n};\nconst staticMethods = baseStaticMethods;\nmethods.forEach(type => {\n  staticMethods[type] = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return typeOpen(type, args);\n  };\n});\n// ==============================================================================\n// ==                                   Test                                   ==\n// ==============================================================================\nconst noop = () => {};\n/** @internal Only Work in test env */\n// eslint-disable-next-line import/no-mutable-exports\nexport let actWrapper = noop;\nif (process.env.NODE_ENV === 'test') {\n  actWrapper = wrapper => {\n    act = wrapper;\n  };\n}\n/** @internal Only Work in test env */\n// eslint-disable-next-line import/no-mutable-exports\nexport let actDestroy = noop;\nif (process.env.NODE_ENV === 'test') {\n  actDestroy = () => {\n    message = null;\n  };\n}\nexport default staticMethods;"],"names":["useAuth","auth","_useSearchParams","useSearchParams","_useSearchParams2","_slicedToArray","currentQueryParameters","setSearchParams","error","get","newQueryParameters","useMemo","URLSearchParams","toString","navigate","useNavigate","message","authorizationUtil","setAuthorization","useLoginWithGithub","_useState","useState","_useState2","isLogin","setIsLogin","useEffect","_jsx","Outlet","redirectToLogin","_Fragment","act","callback","taskQueue","defaultGlobalConfig","getGlobalContext","prefixCls","globalPrefixCls","getContainer","globalGetContainer","duration","rtl","maxCount","top","mergedPrefixCls","getPrefixCls","mergedContainer","document","body","GlobalHolder","_","ref","messageConfig","setMessageConfig","api","holder","global","rootPrefixCls","getRootPrefixCls","rootIconPrefixCls","getIconPrefixCls","theme","getTheme","sync","instance","Object","assign","keys","forEach","method","apply","arguments","iconPrefixCls","flushNotice","holderFragment","createDocumentFragment","newMessage","fragment","node","Promise","resolve","then","task","type","skipped","closeFn","open","config","setCloseFn","destroy","key","_message$instance","args","staticMethods","result","fn","push","_a","call","useMessage","_InternalPanelDoNotUseOrYouWillBeFired","_len","length","Array","_key","typeOpen"],"sourceRoot":""}